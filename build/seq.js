export class Sequence{constructor(e){this._generator=e}static range(e,t,n=1){return new Sequence((()=>function*(e,t,n){for(let r=e;r<t;r+=n)yield r}(e,t,n)))}static rangeClosed(e,t,n=1){return Sequence.range(e,t+1,n)}static iterate(e,t,n=(e=>!0)){return new Sequence((()=>function*(e,t,n){for(let r=e;!0===n(r);r=t(r))yield r}(e,t,n)))}static generate(e){return new Sequence((()=>function*(e){for(;;)yield e()}(e)))}static of(...t){return new Sequence((()=>e(t)))}filter(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done)break;!0===e(t.value)&&(yield t.value)}}(e,this._generator)))}map(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done)break;yield e(t.value)}}(e,this._generator)))}flatMap(e){return new Sequence((()=>function*(e,t){const n=t();for(const t of n){const n=e(t);for(const e of n)yield e}}(e,this._generator)))}limit(e){return new Sequence((()=>function*(e,t){const n=t();let r=0;for(;;){const t=n.next();if(t.done||r===e)break;++r,yield t.value}}(e,this._generator)))}skip(e){return new Sequence((()=>function*(e,t){const n=t();let r=0;for(;;){const t=n.next();if(t.done)break;r++>=e&&(yield t.value)}}(e,this._generator)))}takeWhile(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done||!1===e(t.value))break;yield t.value}}(e,this._generator)))}dropWhile(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done)return;if(!1===e(t.value)){yield t.value;break}}for(const e of n)yield e}(e,this._generator)))}distinct(t=(e=>e)){const n=this._generator(),r=[];e:for(const e of n){const n=t(e);for(const e of r)if(n===t(e))continue e;r.push(e)}return new Sequence((()=>e(r)))}sort(t){const n=this.toArray();return n.sort(t),new Sequence((()=>e(n)))}sortAscending(e=(e=>e)){return this.sort(((t,n)=>{const r=e(t),o=e(n);return r<o?-1:r>o?1:0}))}sortDescending(e=(e=>e)){return this.sort(((t,n)=>{const r=e(t),o=e(n);return r<o?1:r>o?-1:0}))}forEach(e){const t=this._generator();for(const n of t)e(n)}reduce(e,t){const n=this._generator();let r=e;for(const e of n)r=t(r,e);return r}_collect(e,t,n){const r=this._generator();for(const n of r)t(e,n);if(n)for(const[t,r]of Object.entries(e))n(e,t,r);return e}sum(){return this.reduce(0,((e,t)=>e+t))}count(){return this.reduce(0,((e,t)=>e+1))}average(){const e=this._generator();let t=0,n=0;for(const r of e)++t,n+=r;return n/t}join(e=""){return this.toArray().join(e)}min(e=(e=>e)){const t=this._generator(),n=t.next();if(n.done)return null;let r=n.value;for(const n of t)e(n)<e(r)&&(r=n);return r}max(e=(e=>e)){const t=this._generator(),n=t.next();if(n.done)return null;let r=n.value;for(const n of t)e(n)>e(r)&&(r=n);return r}toArray(){return this._collect([],((e,t)=>e.push(t)))}toMap(e,t){return this._collect({},((n,r)=>n[e(r)]=t(r)))}partitionBy(e){return this._collect([[],[]],((t,n)=>t[!0===e(n)?0:1].push(n)))}groupingBy(e,t=Grouper.toArray()){return this._collect({},((n,r)=>{const o=e(r);void 0===n[o]&&(n[o]=t.accumulatorSupplier()),t.accumulatorFunction(n,o,r)}),t.finisherFunction)}first(){const e=this._generator().next();return e.done?null:e.value}last(){const e=this._generator().next();return e.done?null:this.reduce(e.value,((e,t)=>t))}allMatches(e){const t=this._generator();for(const n of t)if(!1===e(n))return!1;return!0}anyMatches(e){const t=this._generator();for(const n of t)if(!0===e(n))return!0;return!1}}export class Grouper{static toArray(){return{accumulatorSupplier:()=>[],accumulatorFunction:(e,t,n)=>e[t].push(n)}}static counting(){return{accumulatorSupplier:()=>0,accumulatorFunction:(e,t,n)=>++e[t]}}static summing(e){return{accumulatorSupplier:()=>0,accumulatorFunction:(t,n,r)=>t[n]+=e(r)}}static averaging(e){return{accumulatorSupplier:()=>({sum:0,count:0}),accumulatorFunction:(t,n,r)=>{t[n].sum+=e(r),++t[n].count},finisherFunction:(e,t,n)=>e[t]=n.sum/n.count}}}function*e(e){for(const t of e)yield t}Array.prototype.sequence=function(){return new Sequence((()=>e(this)))};