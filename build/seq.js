export class Sequence{constructor(t){this.t=t(),this.u=!1}static range(t,n,e=1){return new Sequence((()=>function*(t,n,e){for(let r=t;r<n;r+=e)yield r}(t,n,e)))}static rangeClosed(t,n,e=1){return Sequence.range(t,n+1,e)}static iterate(t,n,e=(t=>!0)){return new Sequence((()=>function*(t,n,e){for(let r=t;!0===e(r);r=n(r))yield r}(t,n,e)))}static generate(t){return new Sequence((()=>function*(t){for(;;)yield t()}(t)))}static empty(){return new Sequence((()=>function*(){}()))}static of(...t){return 1===t.length&&Array.isArray(t[0])?new Sequence((()=>e(t[0]))):new Sequence((()=>e(t)))}filter(t){return n(this),new Sequence((()=>function*(t,n){for(const e of n)!0===t(e)&&(yield e)}(t,this.t)))}map(t){return n(this),new Sequence((()=>function*(t,n){for(const e of n)yield t(e)}(t,this.t)))}flatMap(t){return n(this),new Sequence((()=>function*(t,n){for(const e of n){const n=t(e);for(const t of n)yield t}}(t,this.t)))}take(t){return n(this),new Sequence((()=>function*(t,n){let e=0;for(;;){const r=n.next();if(r.done||e===t)break;++e,yield r.value}}(t,this.t)))}skip(t){return n(this),new Sequence((()=>function*(t,n){let e=0;for(;;){const r=n.next();if(r.done)break;e++>=t&&(yield r.value)}}(t,this.t)))}takeWhile(t){return n(this),new Sequence((()=>function*(t,n){for(;;){const e=n.next();if(e.done||!1===t(e.value))break;yield e.value}}(t,this.t)))}skipWhile(t){return n(this),new Sequence((()=>function*(t,n){for(;;){const e=n.next();if(e.done)return;if(!1===t(e.value)){yield e.value;break}}for(const t of n)yield t}(t,this.t)))}distinct(t=(t=>t)){return n(this),new Sequence((()=>function*(t,n){const e=[];t:for(const r of n){const n=t(r);for(const r of e)if(n===t(r))continue t;e.push(r),yield r}}(t,this.t)))}sort(t){const n=this.toArray();return n.sort(t),new Sequence((()=>e(n)))}sortAscending(t=(t=>t)){return this.sort(((n,e)=>{const r=t(n),u=t(e);return r<u?-1:r>u?1:0}))}sortDescending(t=(t=>t)){return this.sort(((n,e)=>{const r=t(n),u=t(e);return r<u?1:r>u?-1:0}))}chunk(t){return n(this),new Sequence((()=>function*(t,n){for(;;){const e=[];for(let r=0;r<t;++r){const t=n.next();if(t.done)break;e.push(t.value)}if(0===e.length)break;yield e}}(t,this.t)))}forEach(t){n(this);for(const n of this.t)t(n)}reduce(t,e){n(this);let r=t;for(const t of this.t)r=e(r,t);return r}sum(){return this.reduce(0,((t,n)=>t+n))}count(){return this.reduce(0,((t,n)=>t+1))}average(){const{sum:n,count:e}=t({count:0,sum:0},this,((t,n)=>{++t.count,t.sum+=n}));return 0===e?null:n/e}statistics(){const{sum:n,count:e,min:r,max:u}=t({sum:0,count:0,min:Number.MAX_SAFE_INTEGER,max:Number.MIN_SAFE_INTEGER},this,((t,n)=>{++t.count,t.sum+=n,t.min=Math.min(t.min,n),t.max=Math.max(t.max,n)}));return 0===e?null:{sum:n,count:e,min:r,max:u,average:n/e}}join(t=""){return this.toArray().join(t)}min(t=(t=>t)){const n=this.t.next();return this.reduce(n.done?null:n.value,((n,e)=>t(n)<t(e)?n:e))}max(t=(t=>t)){const n=this.t.next();return this.reduce(n.done?null:n.value,((n,e)=>t(n)>t(e)?n:e))}toArray(){return t([],this,((t,n)=>t.push(n)))}toMap(n,e,r=((t,n,e)=>{throw`Duplicate value found for key: '${t}', previous value: '${n}', current value: '${e}'`})){return t(new Map,this,((t,u)=>{const i=n(u),o=e(u),c=t.get(i);t.set(i,void 0===c?o:r(i,c,o))}))}partitionBy(n){return t([[],[]],this,((t,e)=>t[!0===n(e)?0:1].push(e)))}groupBy(n,e=Grouper.toArray()){const r=t(new Map,this,((t,r)=>{const u=n(r);t.has(u)||t.set(u,e.i()),e.o(t,u,r)})),u=e.h;if(u)for(const[t,n]of r.entries())u(r,t,n);return r}first(){n(this);const t=this.t.next();return t.done?null:t.value}last(){const t=this.t.next();return this.reduce(t.done?null:t.value,((t,n)=>n))}allMatches(t){n(this);for(const n of this.t)if(!1===t(n))return!1;return!0}anyMatches(t){n(this);for(const n of this.t)if(!0===t(n))return!0;return!1}}export class Grouper{static toArray(){return{i:()=>[],o:(t,n,e)=>t.get(n).push(e)}}static counting(){return{i:()=>0,o:(t,n,e)=>t.set(n,t.get(n)+1)}}static summing(t){return{i:()=>0,o:(n,e,r)=>n.set(e,n.get(e)+t(r))}}static averaging(t){return{i:()=>({sum:0,count:0}),o:(n,e,r)=>{const u=n.get(e);u.sum+=t(r),++u.count},h:(t,n,e)=>t.set(n,e.sum/e.count)}}static statisticizing(t){return{i:()=>({sum:0,count:0,min:Number.MAX_SAFE_INTEGER,max:Number.MIN_SAFE_INTEGER}),o:(n,e,r)=>{const u=n.get(e),i=t(r);++u.count,u.sum+=i,u.min=Math.min(u.min,i),u.max=Math.max(u.max,i)},h:(t,n,e)=>t.set(n,{sum:e.sum,count:e.count,min:e.min,max:e.max,average:e.sum/e.count})}}}function t(t,e,r){n(e);for(const n of e.t)r(t,n);return t}function n(t){if(t.u)throw new Error("Sequence was already terminated!");t.u=!0}function*e(t){for(const n of t)yield n}