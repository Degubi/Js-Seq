export class Sequence{constructor(e){this._generator=e}static range(e,t,n=1){return new Sequence((()=>function*(e,t,n){for(let r=e;r<t;r+=n)yield r}(e,t,n)))}static rangeClosed(e,t,n=1){return Sequence.range(e,t+1,n)}static iterate(e,t,n=(e=>!0)){return new Sequence((()=>function*(e,t,n){for(let r=e;!0===n(r);r=t(r))yield r}(e,t,n)))}static generate(e){return new Sequence((()=>function*(e){for(;;)yield e()}(e)))}static of(...t){return new Sequence((()=>e(t)))}filter(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done)break;!0===e(t.value)&&(yield t.value)}}(e,this._generator)))}map(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done)break;yield e(t.value)}}(e,this._generator)))}limit(e){return new Sequence((()=>function*(e,t){const n=t();let r=0;for(;;){const t=n.next();if(t.done||r===e)break;++r,yield t.value}}(e,this._generator)))}skip(e){return new Sequence((()=>function*(e,t){const n=t();let r=0;for(;;){const t=n.next();if(t.done)break;r++>=e&&(yield t.value)}}(e,this._generator)))}takeWhile(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done||!1===e(t.value))break;yield t.value}}(e,this._generator)))}distinct(t=(e=>e)){const n=this._generator(),r=[];e:for(const e of n){for(const n of r)if(t(e)===t(n))continue e;r.push(e)}return new Sequence((()=>e(r)))}sortAscending(t=(e=>e)){const n=this.toArray();return n.sort(((e,n)=>{const r=t(e),o=t(n);return r<o?-1:r>o?1:0})),new Sequence((()=>e(n)))}sortDescending(t=(e=>e)){const n=this.toArray();return n.sort(((e,n)=>{const r=t(e),o=t(n);return r<o?1:r>o?-1:0})),new Sequence((()=>e(n)))}forEach(e){const t=this._generator();for(const n of t)e(n)}reduce(e,t){const n=this._generator();let r=e;for(const e of n)r=t(r,e);return r}_collect(e,t){const n=this._generator();for(const r of n)t(e,r);return e}sum(){return this.reduce(0,((e,t)=>e+t))}count(){return this.reduce(0,((e,t)=>e+1))}min(e=(e=>e)){const t=this._generator(),n=t.next();if(n.done)return Optional.empty();let r=n.value;for(const n of t)e(n)<e(r)&&(r=n);return Optional.of(r)}max(e=(e=>e)){const t=this._generator(),n=t.next();if(n.done)return Optional.empty();let r=n.value;for(const n of t)e(n)>e(r)&&(r=n);return Optional.of(r)}toArray(){return this._collect([],((e,t)=>e.push(t)))}toMap(e,t){return this._collect({},((n,r)=>n[e(r)]=t(r)))}partitionBy(e){return this._collect([[],[]],((t,n)=>t[!0===e(n)?0:1].push(n)))}first(){const e=this._generator();for(const t of e)return Optional.of(t);return Optional.empty()}allMatches(e){const t=this._generator();for(const n of t)if(!1===e(n))return!1;return!0}anyMatches(e){const t=this._generator();for(const n of t)if(!0===e(n))return!0;return!1}}export class Optional{static empty_optional=new Optional;constructor(e,t){this.value=e,this.hasValue=t}static empty(){return Optional.empty_optional}static of(e){if(null==e)throw"Can't put null or undefined into an optional!";return new Optional(e,!0)}static ofNullable(e){return new Optional(e,null!=e)}}function*e(e){for(const t of e)yield t}Array.prototype.sequence=function(){return new Sequence((()=>e(this)))};