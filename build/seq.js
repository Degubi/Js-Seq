export class Sequence{constructor(e){this._generator=e}static range(e,t,n=1){return new Sequence((()=>function*(e,t,n){for(let r=e;r<t;r+=n)yield r}(e,t,n)))}static rangeClosed(e,t,n=1){return Sequence.range(e,t+1,n)}static iterate(e,t,n=(e=>!0)){return new Sequence((()=>function*(e,t,n){for(let r=e;!0===n(r);r=t(r))yield r}(e,t,n)))}static generate(e){return new Sequence((()=>function*(e){for(;;)yield e()}(e)))}static empty(){return new Sequence((()=>function*(){}()))}static of(...e){return new Sequence((()=>n(e)))}filter(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done)break;!0===e(t.value)&&(yield t.value)}}(e,this._generator)))}map(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done)break;yield e(t.value)}}(e,this._generator)))}flatMap(e){return new Sequence((()=>function*(e,t){const n=t();for(const t of n){const n=e(t);for(const e of n)yield e}}(e,this._generator)))}take(e){return new Sequence((()=>function*(e,t){const n=t();let r=0;for(;;){const t=n.next();if(t.done||r===e)break;++r,yield t.value}}(e,this._generator)))}skip(e){return new Sequence((()=>function*(e,t){const n=t();let r=0;for(;;){const t=n.next();if(t.done)break;r++>=e&&(yield t.value)}}(e,this._generator)))}takeWhile(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done||!1===e(t.value))break;yield t.value}}(e,this._generator)))}skipWhile(e){return new Sequence((()=>function*(e,t){const n=t();for(;;){const t=n.next();if(t.done)return;if(!1===e(t.value)){yield t.value;break}}for(const e of n)yield e}(e,this._generator)))}distinct(e=(e=>e)){const t=this._generator(),r=[];e:for(const n of t){const t=e(n);for(const n of r)if(t===e(n))continue e;r.push(n)}return new Sequence((()=>n(r)))}sort(e){const t=this.toArray();return t.sort(e),new Sequence((()=>n(t)))}sortAscending(e=(e=>e)){return this.sort(((t,n)=>{const r=e(t),o=e(n);return r<o?-1:r>o?1:0}))}sortDescending(e=(e=>e)){return this.sort(((t,n)=>{const r=e(t),o=e(n);return r<o?1:r>o?-1:0}))}forEach(e){const t=this._generator();for(const n of t)e(n)}reduce(t,n){return e(t,this._generator(),n)}sum(){return this.reduce(0,((e,t)=>e+t))}count(){return this.reduce(0,((e,t)=>e+1))}average(){const{sum:e,count:n}=t({count:0,sum:0},this._generator(),((e,t)=>{++e.count,e.sum+=t}));return 0===n?null:e/n}join(e=""){return this.toArray().join(e)}min(t=(e=>e)){const n=this._generator(),r=n.next();return r.done?null:e(r.value,n,((e,n)=>t(e)<t(n)?e:n))}max(t=(e=>e)){const n=this._generator(),r=n.next();return r.done?null:e(r.value,n,((e,n)=>t(e)>t(n)?e:n))}toArray(){return t([],this._generator(),((e,t)=>e.push(t)))}toMap(e,n,r=((e,t,n)=>{throw`Duplicate value found for key: '${e}', previous value: '${t}', current value: '${n}'`})){return t({},this._generator(),((t,o)=>{const u=e(o),c=n(o);void 0===t[u]?t[u]=c:t[u]=r(u,t[u],c)}))}partitionBy(e){return t([[],[]],this._generator(),((t,n)=>t[!0===e(n)?0:1].push(n)))}chunking(e){const n=this._generator(),r=n.next();return r.done?[]:t([[r.value]],n,((t,n)=>{const r=t[t.length-1];r.length===e?t.push([n]):r.push(n)}))}groupingBy(e,n=Grouper.toArray()){const r=t({},this._generator(),((t,r)=>{const o=e(r);void 0===t[o]&&(t[o]=n.accumulatorSupplier()),n.accumulatorFunction(t,o,r)})),o=n.finisherFunction;if(o)for(const[e,t]of Object.entries(r))o(r,e,t);return r}first(){const e=this._generator().next();return e.done?null:e.value}last(){const e=this._generator().next();return e.done?null:this.reduce(e.value,((e,t)=>t))}allMatches(e){const t=this._generator();for(const n of t)if(!1===e(n))return!1;return!0}anyMatches(e){const t=this._generator();for(const n of t)if(!0===e(n))return!0;return!1}}export class Grouper{static toArray(){return{accumulatorSupplier:()=>[],accumulatorFunction:(e,t,n)=>e[t].push(n)}}static counting(){return{accumulatorSupplier:()=>0,accumulatorFunction:(e,t,n)=>++e[t]}}static summing(e){return{accumulatorSupplier:()=>0,accumulatorFunction:(t,n,r)=>t[n]+=e(r)}}static averaging(e){return{accumulatorSupplier:()=>({sum:0,count:0}),accumulatorFunction:(t,n,r)=>{t[n].sum+=e(r),++t[n].count},finisherFunction:(e,t,n)=>e[t]=n.sum/n.count}}}function e(e,t,n){let r=e;for(const e of t)r=n(r,e);return r}function t(e,t,n){for(const r of t)n(e,r);return e}function*n(e){for(const t of e)yield t}Array.prototype.sequence=function(){return new Sequence((()=>n(this)))};