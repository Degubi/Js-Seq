export class Sequence{constructor(t){this.t=t(),this.i=!1}static range(t,n,e=1){return new Sequence((()=>function*(t,n,e){for(let r=t;r<n;r+=e)yield r}(t,n,e)))}static rangeClosed(t,n,e=1){return Sequence.range(t,n+1,e)}static iterate(t,n,e=(t=>!0)){return new Sequence((()=>function*(t,n,e){for(let r=t;!0===e(r);r=n(r))yield r}(t,n,e)))}static generate(t){return new Sequence((()=>function*(t){for(;;)yield t()}(t)))}static empty(){return new Sequence((()=>function*(){}()))}static of(...t){return 1===t.length&&Array.isArray(t[0])?new Sequence((()=>e(t[0]))):new Sequence((()=>e(t)))}filter(t){return n(this),new Sequence((()=>function*(t,n){for(const e of n)!0===t(e)&&(yield e)}(t,this.t)))}map(t){return n(this),new Sequence((()=>function*(t,n){for(const e of n)yield t(e)}(t,this.t)))}flatMap(t){return n(this),new Sequence((()=>function*(t,n){for(const e of n){const n=t(e);for(const t of n)yield t}}(t,this.t)))}take(t){return n(this),new Sequence((()=>function*(t,n){let e=0;for(;;){const r=n.next();if(r.done||e===t)break;++e,yield r.value}}(t,this.t)))}skip(t){return n(this),new Sequence((()=>function*(t,n){let e=0;for(;;){const r=n.next();if(r.done)break;e++>=t&&(yield r.value)}}(t,this.t)))}takeWhile(t){return n(this),new Sequence((()=>function*(t,n){for(;;){const e=n.next();if(e.done||!1===t(e.value))break;yield e.value}}(t,this.t)))}skipWhile(t){return n(this),new Sequence((()=>function*(t,n){for(;;){const e=n.next();if(e.done)return;if(!1===t(e.value)){yield e.value;break}}for(const t of n)yield t}(t,this.t)))}distinct(t=(t=>t)){return n(this),new Sequence((()=>function*(t,n){const e=[];t:for(const r of n){const n=t(r);for(const r of e)if(n===t(r))continue t;e.push(r),yield r}}(t,this.t)))}sort(t){const n=this.toArray();return n.sort(t),new Sequence((()=>e(n)))}sortAscending(t=(t=>t)){return this.sort(((n,e)=>{const r=t(n),i=t(e);return r<i?-1:r>i?1:0}))}sortDescending(t=(t=>t)){return this.sort(((n,e)=>{const r=t(n),i=t(e);return r<i?1:r>i?-1:0}))}chunk(t){return n(this),new Sequence((()=>function*(t,n){for(;;){const e=[];for(let r=0;r<t;++r){const t=n.next();if(t.done)break;e.push(t.value)}if(0===e.length)break;yield e}}(t,this.t)))}forEach(t){n(this);for(const n of this.t)t(n)}reduce(t,e){n(this);let r=t;for(const t of this.t)r=e(r,t);return r}sum(){return this.reduce(0,((t,n)=>t+n))}count(){return this.reduce(0,((t,n)=>t+1))}average(){const{sum:n,count:e}=t({count:0,sum:0},this,((t,n)=>{++t.count,t.sum+=n}));return 0===e?null:n/e}join(t=""){return this.toArray().join(t)}min(t=(t=>t)){const n=this.t.next();return this.reduce(n.done?null:n.value,((n,e)=>t(n)<t(e)?n:e))}max(t=(t=>t)){const n=this.t.next();return this.reduce(n.done?null:n.value,((n,e)=>t(n)>t(e)?n:e))}toArray(){return t([],this,((t,n)=>t.push(n)))}toMap(n,e,r=((t,n,e)=>{throw`Duplicate value found for key: '${t}', previous value: '${n}', current value: '${e}'`})){return t(new Map,this,((t,i)=>{const o=n(i),u=e(i),c=t.get(o);t.set(o,void 0===c?u:r(o,c,u))}))}partitionBy(n){return t([[],[]],this,((t,e)=>t[!0===n(e)?0:1].push(e)))}groupingBy(n,e=Grouper.toArray()){const r=t(new Map,this,((t,r)=>{const i=n(r);t.has(i)||t.set(i,e.o()),e.u(t,i,r)})),i=e.l;if(i)for(const[t,n]of r.entries())i(r,t,n);return r}first(){n(this);const t=this.t.next();return t.done?null:t.value}last(){const t=this.t.next();return this.reduce(t.done?null:t.value,((t,n)=>n))}allMatches(t){n(this);for(const n of this.t)if(!1===t(n))return!1;return!0}anyMatches(t){n(this);for(const n of this.t)if(!0===t(n))return!0;return!1}}export class Grouper{static toArray(){return{o:()=>[],u:(t,n,e)=>t.get(n).push(e)}}static counting(){return{o:()=>0,u:(t,n,e)=>t.set(n,t.get(n)+1)}}static summing(t){return{o:()=>0,u:(n,e,r)=>n.set(e,n.get(e)+t(r))}}static averaging(t){return{o:()=>({sum:0,count:0}),u:(n,e,r)=>{const i=n.get(e);i.sum+=t(r),++i.count},l:(t,n,e)=>t.set(n,e.sum/e.count)}}}function t(t,e,r){n(e);for(const n of e.t)r(t,n);return t}function n(t){if(t.i)throw new Error("Sequence was already terminated!");t.i=!0}function*e(t){for(const n of t)yield n}