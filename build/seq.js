export class Sequence{constructor(t){this._generator=t}static range(t,e,n=1){return new Sequence((()=>function*(t,e,n){for(let r=t;r<e;r+=n)yield r}(t,e,n)))}static rangeClosed(t,e,n=1){return Sequence.range(t,e+1,n)}static iterate(t,e,n=(t=>!0)){return new Sequence((()=>function*(t,e,n){for(let r=t;!0===n(r);r=e(r))yield r}(t,e,n)))}static generate(t){return new Sequence((()=>function*(t){for(;;)yield t()}(t)))}static of(...e){return new Sequence((()=>t(e)))}filter(t){return new Sequence((()=>function*(t,e){const n=e();for(;;){const e=n.next();if(e.done)break;!0===t(e.value)&&(yield e.value)}}(t,this._generator)))}map(t){return new Sequence((()=>function*(t,e){const n=e();for(;;){const e=n.next();if(e.done)break;yield t(e.value)}}(t,this._generator)))}flatMap(t){return new Sequence((()=>function*(t,e){const n=e();for(const e of n){const n=t(e);for(const t of n)yield t}}(t,this._generator)))}limit(t){return new Sequence((()=>function*(t,e){const n=e();let r=0;for(;;){const e=n.next();if(e.done||r===t)break;++r,yield e.value}}(t,this._generator)))}skip(t){return new Sequence((()=>function*(t,e){const n=e();let r=0;for(;;){const e=n.next();if(e.done)break;r++>=t&&(yield e.value)}}(t,this._generator)))}takeWhile(t){return new Sequence((()=>function*(t,e){const n=e();for(;;){const e=n.next();if(e.done||!1===t(e.value))break;yield e.value}}(t,this._generator)))}distinct(e=(t=>t)){const n=this._generator(),r=[];t:for(const t of n){const n=e(t);for(const t of r)if(n===e(t))continue t;r.push(t)}return new Sequence((()=>t(r)))}sort(e){const n=this.toArray();return n.sort(e),new Sequence((()=>t(n)))}sortAscending(t=(t=>t)){return this.sort(((e,n)=>{const r=t(e),o=t(n);return r<o?-1:r>o?1:0}))}sortDescending(t=(t=>t)){return this.sort(((e,n)=>{const r=t(e),o=t(n);return r<o?1:r>o?-1:0}))}forEach(t){const e=this._generator();for(const n of e)t(n)}reduce(t,e){const n=this._generator();let r=t;for(const t of n)r=e(r,t);return r}_collect(t,e,n){const r=this._generator();for(const n of r)e(t,n);if(n)for(const[e,r]of Object.entries(t))n(t,e,r);return t}sum(){return this.reduce(0,((t,e)=>t+e))}count(){return this.reduce(0,((t,e)=>t+1))}average(){const t=this._generator();let e=0,n=0;for(const r of t)++e,n+=r;return n/e}join(t=""){return this.toArray().join(t)}min(t=(t=>t)){const e=this._generator(),n=e.next();if(n.done)return Optional.empty();let r=n.value;for(const n of e)t(n)<t(r)&&(r=n);return Optional.of(r)}max(t=(t=>t)){const e=this._generator(),n=e.next();if(n.done)return Optional.empty();let r=n.value;for(const n of e)t(n)>t(r)&&(r=n);return Optional.of(r)}toArray(){return this._collect([],((t,e)=>t.push(e)))}toMap(t,e){return this._collect({},((n,r)=>n[t(r)]=e(r)))}partitionBy(t){return this._collect([[],[]],((e,n)=>e[!0===t(n)?0:1].push(n)))}groupingBy(t,e=Grouper.toArray()){return this._collect({},((n,r)=>{const o=t(r);void 0===n[o]&&(n[o]=e.accumulatorSupplier()),e.accumulatorFunction(n,o,r)}),e.finisherFunction)}first(){const t=this._generator().next();return t.done?Optional.empty():Optional.of(t.value)}last(){const t=this._generator().next();return t.done?Optional.empty():this.reduce(t.value,((t,e)=>e))}allMatches(t){const e=this._generator();for(const n of e)if(!1===t(n))return!1;return!0}anyMatches(t){const e=this._generator();for(const n of e)if(!0===t(n))return!0;return!1}}export class Grouper{static toArray(){return{accumulatorSupplier:()=>[],accumulatorFunction:(t,e,n)=>t[e].push(n)}}static counting(){return{accumulatorSupplier:()=>0,accumulatorFunction:(t,e,n)=>++t[e]}}static summing(t){return{accumulatorSupplier:()=>0,accumulatorFunction:(e,n,r)=>e[n]+=t(r)}}static averaging(t){return{accumulatorSupplier:()=>({sum:0,count:0}),accumulatorFunction:(e,n,r)=>{e[n].sum+=t(r),++e[n].count},finisherFunction:(t,e,n)=>t[e]=n.sum/n.count}}}export class Optional{static empty_optional=new Optional;constructor(t,e){this.value=t,this.hasValue=e}static empty(){return Optional.empty_optional}static of(t){if(null==t)throw"Can't put null or undefined into an optional!";return new Optional(t,!0)}static ofNullable(t){return new Optional(t,null!=t)}}function*t(t){for(const e of t)yield e}Array.prototype.sequence=function(){return new Sequence((()=>t(this)))};